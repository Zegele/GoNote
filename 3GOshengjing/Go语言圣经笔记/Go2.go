第二章 程序结构

2.1 命名

1. 命名的规则（p53）
Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个
简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意
数量的字母、数字或下划线。大写字母和小写字母是不同的：heapSort和Heapsort是两个不
同的名字

2. 关键字（p53）
关键字不能用于自定义名字，只能在特定语法结构中使用。
25个关键字
break default func interface select 
case defer go map struct 
chan else goto package switch
const fallthrough if range type
continue for import return var

3.内建常量：true false iota(印象差点) nil

4.内建类型：
int int8 int16 int32 int64
uint uint8 uint16 uint32 uint64 uintptr
float32 float64 complex128 complex64
bool byte rune string error

5.内建函数：（p53）
make len cap new append copy close delete
complex real imag panic recover 

6. 名字的位置
如果一个名字是在函数内部定义，那么它的就只在函数内部有效。
如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。

7. 名字与包
如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函
数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问，例如fmt包的
Printf函数就是导出的，可以在fmt包外部访问。包本身的名字一般总是用小写字母。

2.2声明（这章重点是变量和类型的声明）

8. 声明语句定义了程序的各种实体对象以及部分或全部的属性。
Go语言主要有四种类型的声明语句：var\const\type\func,分别对应变量、常量、类型和函数实体对象的声明。

9. 一个函数的声明
一个函数的声明由一个函数的名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表，和包含函数定义的函数体组成。
如果函数没有返回值，那么返回值列表是省略的。
执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句。
如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。
//谁请求了函数，谁就是函数的调用者？？？

2.3 变量

10. var (p57)
var声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。
var 变量名字 类型 = 表达式
其中“类型”或“=表达式”两个部分可以省略其中的一个。
如果省略的是“类型”，那么将根据初始化表达式来退到变量的类型信息。
如果“初始化表达式被省略”，那么将用零值初始化该变量。

数值类型变量对应的零值是0
布尔类型变量对应的零值是false
字符串类型对应的零值是空字符串，如：""。
接口或引用类型（包括slice，map，chan和函数）变量对应的零值是nil。
数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。

Go语言中不存在未初始化的变量。
var s string
fmt.Println(s) // ""


可以在一个声明语句中同时声明一组变量，
var i, j, k int //int, int, int

或用一组初始化表达式声明并初始化一组变量。
var b, f, s = true, 2.3, "four" //bool, float64, string

11. 初始化表达式可以是字面量或任意的表达式。
在包级别声明的变量会在main入口函数执行前完成初始化。（参考 2.6.2）
局部变量将在声明语句被执行到的时候完成初始化。

一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：
var f, err = os.Open(name) // os.Open returns a file and an error


2.3.1 简短变量声明（p58）

12. 在函数内部，有一种称为简短变量声明语句的形式可用于声明和初始化局部变量。

anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64()*3.0
t:=0.0
//例子来源于1.4的lissajous函数

13. 简短变量声明被广泛用于大部分的局部变量的声明和初始化。
var往往用于需要显示指定变量类型的地方，或者变量稍后会被重新复制而初始值无关紧要的地方。

i:= 100 // an int 
var boiling float = 100 // a float 64
var names []string
var err error
var p Point

14. 和var形式声明语句一样，
简短变量声明语句也可以用来声明和初始化一组变量。
i, j := 0, 1
但这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用。

记住： ：= 是一个变量声明语句。
        = 是一个变量赋值操作。
也不要混淆多个变量的声明和元组的多重赋值（2.4.1元组多重赋值：将右边各个表达式值赋值给左边对应位置的各个变量）
元组的多重赋值：i, j= j, i //把右边j, i赋值给左边的i, j

:=也可以用函数的返回值来声明和初始化变量，如：

f, err := os.Open(name)
if err !=nil{
	return err
}
// ...use f...
f.Close()

15. ：= 中一个微妙的地方
简短变量声明左边的变量可能并不是全部都是刚刚声明的。
如果有一些已经在相同的词法域声明过了（2.7），那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了。
in, err := os.Open(infile)
//...
out, err := os.Create(outfile)
第一个语句声明了in和err两个变量，
第二个语句只声明了out一个变量，然后对之前已经声明的err进行了赋值操作。

并且，简短声明语句中必须至少要声明一个新的变量，
否则不能编译通过，如：
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) //compile error:no new variables
想一想就可以理解，如果完全一样就没必要重新声明，直接用就行了。
解决的方法是第二个简短变量声明语句改用普通的多重赋值语言，即可。

16.简短变量声明 与 词法域 （p59）
简短变量声明语句只有对已经在统计词法域声明过的变量才和赋值操作语句等价。
如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

2.3.2 指针（一字不差地阅读这三段文字，以及示例代码，以理解指针）
17.指针（p59）
一个变量对应一个保存了变量对应类型值的内存空间。
普通变量在声明语句创建时被绑定到一个变量名，比如叫x的变量，但还有很多变量始终以表达式方式引入，例如x[i]或x.f变量。
所有这些表达式一般都是读取一个变量的值，除非它们是出现在赋值语句的左边，这种时候是个对应变量赋予一个新的值。

一个指针的值是另一个变量的地址。一个指针对应变量在内存中的储存位置（内存地址）。
并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。
通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字（如果变量有名字的话）。

如果用“var x int”声明语句声明一个x变量，那么&x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，
指针对应的数据类型是*int，
指针被称之为“指向int类型的指针”。
如果指针名字为p，那么可以说“p指针指向变量x”，
或者说“p指针保存了x变量的内存地址”。
同时*p表达式对应p指针指向的变量的值。
一般*p表达式读取指针指向的变量的值，这里为int类型的值。
同时因为*p对应一个变量，多以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。
x := 1
p := &x //p,of type *int, points to x 
//p是指针；“p指针指向变量x”或“p指针保存了x变量的内存地址”
fmt.Println(*p) // "1" 取指针指向的变量的值
fmt.Println(p) //会打印出保存的内存地址？？？（这一条是自己加的）
*p = 2 //equivalent to x = 2 通过指针改变了变量的值。
fmt.Println(x) // "2"

18.指针二（p60）
对于聚合类型每个成员——比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。
变量有时候被称为可寻址的值。
即使变量由表达式临时生成，那么表达式也必须能接受&取地址操作。

19.指针三（p60）
任何类型的指针的零值都是nil。
(这里说的是指针的零值，不是变量的零值，注意区分。可以这样理解指针零值：当这个指针没有所指时，这个指针就是零值状态)
如果 p!=nil 测试为真，那么p是指向某个有效变量。
指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。
var x, y int
fmt.Println(&x == &x, &x == &y, &x == nil) 
//"true false false"
x,y是两个不同的变量，虽然都是int型，而且初始值都是零值。
但它们都有各自的内存地址，且对应的地址是不一致的。
所以&x != &y
&x ！= nil（因为&x已经指向了x，而且x是有初始值的也就是零值，所以&x不为空的）


20.指针四（p60）
在Go语言中，返回函数中局部变量的地址也是安全的。
例如下面的代码，调用f函数时创建局部变量v,在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。
var p = f()

func f() *int{
	v:=1
	return &v
}

但每次调用f函数都将返回不同的结果。
因为指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过指针来更新变量的值。
例如下面例子就是通过指针来更新变量的值，然后返回更新后的值，可用在一个表达式中。
func incr(p *int) int{
	*p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针，也就是不改变该变量的内存地址。
	return *p
}

v:=1
incr(&v)
fmt.Println(incr(&v))

21.指针五（p60）
每次我们对一个变量取地址，或者赋值指针，我们都是为原变量创建了新的别名。
例如，*p就是变量v的别名。
指针特别有价值的地方就在于我们可以不用名字而访问一个变量，
但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名（这是Go语言的垃圾回收器所做的工作）
不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如：slice，map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。

22. 指针六（p61）
指针是实现标准库中flag包的关键技术，它使用命令行参数来设置对应变量的值，
而这些对应命令行标志参数的变量可能会零散分布在整个程序中。
为了说明这一点，在早些echo版本中，就包含了两个可选的命令行参数：-n用于忽略行尾的换行符，-s sep用于制定分隔字符（默认是空格）。
下面这是第四个版本，对应包路径为gopl.io/ch2/echo4


2.3.3 new函数（p62）

23. new函数创建变量（创建指针）（p62）
另一个创建变量的方法是调用内建的new函数。
相当于直接创建了一个指针。指针指向的是一个匿名变量。
表达式 new(T) 将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针了类型为*T。
p := new(int) //p, *int类型，指向匿名的int变量。
fmt.Println(p)
fmt.Println(*p)//"0"
*p = 2
fmt.Println(p)
fmt.Pritnln(*p)

下面两种表达效果一样：
func newInt() *int{//这里的*int是相应的指针类型,是一个内存地址。*p是表示指针所指变量的值。注意区分这两个东西。
	return new(int)
}

func newInt() *int{
	var dummy int
	return &dummy
}

24. new函数二（p62）
每次调用new函数都是返回一个新的变量的地址，因此下面两个地址是不同的：
p := new(int)
q := new(int)
fmt.Println(p == q) //"false"

当然也可能有特殊情况：如果两个类型都是空的，也就是说类型的大小是0
例如struct{}和[0]int,有可能有相同的地址（依赖具体的语言实现）（请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看 runtime.SetFinalizer 函数相关文档）

new函数使用相对较少，因为对结构体来说，可以直接用字面语法创建新变量的方法会更灵活。

由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型。如下：
func delta(old, new int) int{ return new - old}
由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的。


2.3.4 变量的生命周期(p63)

25. 变量的生命周期指：在程序运行期间变量有效存在的时间间隔（时间段）。

对于包一级声明的变量，它的生命周期和整个程序的运行周期是一致的。

局部变量的声明周期则是动态的：每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，
然后变量的存储空间可能被回收。
函数的参数变量和返回值变量都是局部变量。
他们在函数每次被调用的时候创建。

26. 关于括号(p63)
代码来源1.4节摘选
for t := 0.0; t < cycles*2*math.Pi; t += res {
	x := math.Sin(t)
	y := math.Sin(t*freq + phase)
	img.SetColorIndex(size+int(x*size+0.5),size+int(y*size+0.5),
		blackIndex)
}

for t := 0.0; t < cycles*2*math.Pi; t += res {
	x := math.Sin(t)
	y := math.Sin(t*freq + phase)
	img.SetColorIndex(
		size+int(x*size+0.5), size+int(y*size+0.5),
		blackIndex, // 最后插入的都好不会导致编译错误，这是Go编译器的一个特性。
	)//小括号另一行缩进，和大括号的风格保持一致
}

函数有右小括号也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显示插入逗号（参考上面的代码）。


27. 用上面的示例代码演示变量的生命周期。(p64)
在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。

28. 怎样回收变量（p64第二段）

29. 栈上 | 堆上  是什么东西？？（p64第四段）
编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，
但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。

var global *int //global是个指针，指针类型

func f(){
	var x int 
	x = 1
	global = &x
}

func g(){
	y := new(int) //使用new函数创建了一个y指针。y指针的类型是*int。&y可以查看指针指向的内存地址。指向的初始值是0。
	*y = 1 //将指向y内存地址的值，改为1。
}

f函数里的x变量必须在 堆上 分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然他是在函数内部定义的。
用Go语言的术语说，这个x局部变量从函数f中逃逸了。

g函数返回时，变量*y将是不可达的，也就是说可以马上被回收。
因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配 *y的存储空间（也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间）
虽然这里用的是new方式。
其实在任何时候，你并不需为了编写正确的代码而考虑变量的逃逸行为，要记住的是，逃逸的变量需要配额外内存，同时对性能的优化可能会产生细微的影响。

了解了生命周期，就更懂，不要将指向短生命周期对象的指针保存到具有长生命周期的对象中，
特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（可能影响程序的性能）。

2.4赋值（p65）

30. 使用赋值语句可以更新一个变量的值。
x = 1 //命名变量的赋值
*p = true  //通过指针间接赋值，指针不需要知道这个对应的变量叫什么名字。
person.name //结构体字段赋值
count[x] = count[x] * scale //数组、slice或map的元素赋值。

特定的二元算数运算符和赋值语句的复合操作有一个简洁形式，例如上面最后的语句可以重写为：
count[x] *= scale
这样可以省去对变量表达式的重复计算。

数值变量也可以支持++递增和--递减语句（自增、自减是语句，而不是表达式，因此x=i++之类的表达式是错误的）
v := 1
v++ //等价方式 v = v + 1; v变成2
v-- //等价方式 v = v - 1; v变成1

2.4.1元组赋值

x, y = y, x
a[i], a[j] = a[j], a[i]
赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。


31. 计算两个整数值的最大公约数（GCD）（p66）
func gcd(x,y int) int{
	for y != 0 {
		x, y = y, x%y// a%b 就是a除以b，然后获得的余数。
	}
	return x//注意这个x不是for循环里的x
}

32. 斐波那契数列（Fibonacci）的第N个数：
func fib(n int ) int{
	x, y := 0,1 
	for i := 0; i<n; i++{
		x, y = y, x+y
	}
	return x
}

33. 元组赋值也可以使一系列琐碎赋值更加紧凑（特别是for循环的初始化部分）
i, j, k = 2, 3, 5

但如果表达式太复杂的话，应该尽量避免过度使用元组赋值，
因为每个变量单独赋值语句的写法可读性会更好。

34. 函数表达式赋值（p66）
有些表达式会产生多个值，比如调用一个有多个返回值的函数。当这样一个函数调用出现在元组赋值右边的表达式中时（右边不能再有其他表达式），左边变量的数目必须和右边一致。
f, err = os.Open("foo.txt") //function call returns two values

通常，这类函数会用额外的返回值表达某种错误类型，
例如os.Open是用额外的返回值返回一个error类型的错误，
还有一些是用来返回布尔值，通常为成为ok。

如
v, ok = m[key]
v, ok = x.(T)
v, ok = <-ch
map查找（4.3），类型断言（7.10），或通道接收（8.4.2）出现在赋值语句的右边，
他们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功。


35. map查找（4.3），类型断言（7.10），或通道接收（8.4.2）出现在赋值语句的右边时，
并不一定是产生两个结果，也可能只产生一个结果。
对于值产生一个结果的情形，
map查找失败会返回零值，
类型断言失败时会发送运行时panic异常，
通道接收失败时会返回零值（阻塞不算是失败）。
如：
v = m[key] //map查找失败会返回零值，
v = x.(T)//类型断言失败时会发送运行时panic异常，
v = <-ch//通道接收失败时会返回零值（阻塞不算是失败）

_, ok = m[key] //map返回2个值
_, ok = mm[""],false //map返回1个值
_ = mm[""] //map返回1个值（没理解）

36. 用下划线空白标识符  _  ，来丢弃不需要的值。（p67）
_, err = io.Copy(dst,src) //丢弃字节数
_, ok = x.(T) //只检测类型，忽略具体值

2.4.2可赋值性（p67）

37.隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，
一个返回语句将隐式地将返回操作的值赋值给结果变量，
一个复合类型的字面量（4.2）也会产生赋值行为，如下：
medals := []string{"gold", "silver", "bronze"}
隐式地对slice（切片）的每个元素进行赋值操作，类似这样写的行为：
medals[0]="gold"
medals[1]="silver"
medals[2]="bronze"

map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。

38.赋值规则：类型必须完全匹配，nil可以赋值给任何指针或引用类型（包括 slice、map、chan 和 函数 ）的变量。

常量（3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显示的类型转换。（什么意思？？？）

39. 
对于两个值是否可以用==或！=进行相等比较的能力也和可赋值能力有关系：
对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。


2.5 类型(p69)
40. 
一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。
新命名的类型提供了一个方法，用来分隔不同概念的类型，
这样即使它们底层类型相同也是不兼容的。
 type 类型名字 底层类型
类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在外部包也可以使用。

41. 转换类型（p70）
对于每一个类型T，都有一个对应的类型转换操作。
T(x)，用于将x转为T类型
（注：如果T是指针类型，可能会需要用小括弧包装T，如(*int)(0) ）。
只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，
这些转换只改变类型而不会影响值本身。

var c Celsius
var f Fahrenheit
fmt.Println(c==0) //"true"
fmt.Println(f>=0) //"true"
fmt.Println(c==f) //compile error: type mismatch
fmt.Println(c == Celsius(f)) //"true" //不要与函数调用混淆
//Celsius(f) 将f转化为Celsius类型。

42. 名词：方法集（p71）
第六章中讨论细节。
func (c Celsius) String()string{return fmt.Sprintf("%g°C", c)}
//该声明语句，Celsius类型的参数c出现在了函数名的前面，
//表示声明的是适用于Celsius类型的一个叫String()的方法，该方法返回的是该字符串。

许多类型都会定义一个String方法，因为当使用fmt包的打印该方法时，
将会优先使用该类型对应的String方法返回的结果打印。7.1节详述。

示例：
c := FToC(212.0)
fmt.Println(c.String()) //"100°C"
//注意c.String的表述方式，就是那种前置参数的做法。
fmt.Printf("%v\n", c) //"100°C" ; no need to call String explicitly无需显式地调用String方法。
fmt.Printf("%s\n", c) //"100°C"
fmt.Println(c) //"100°C"
fmt.Printf("%g\n",c) //"100"; does not call String //没有调用String()
fmt.Println(float64(c)) //"100" dose not call String

2.6 包和文件
43. 包（p72）
Go语言中，包的目的是为了支持模块化、封装、单独编译和代码重用。
包的路径：包gopl.io/ch1/hellowworld对应的目录路径是$GOPATH/src/gopl.io/ch1/hellowworld

44. 访问包（p72）
每个包都对应一个独立的名字空间。
要在外部引用的函数，必须显式使用类似image.Decode或utf16.Decode（包名.函数名）形式访问。

45. 访问源文件（p73）参照例子
每个源文件都是以包的声明语句开始，用来指明包的名字。
当包被导入的时候，包内的成员将通过类似tempconv.CToF（包名.函数名）的形式访问。

要使用tempconv包，就要先import导入GoNote\3GOshengjing\ch2\tempconv（包的路径从src之后的路径）
然后就可以使用如下：
fmt.Println(tempconv.CToF(tempconv.BoilingC)) 
tempconv.CToF是调用这个包的函数。
tempconv.BoilingC是调用这个包的常量。

46. 包注释（p73）
包注释的第一句应该是包的功能概要说明。
一个包通常只有一个源文件有包注释。（如果有多个包注释，目前的文档工具会根据源文件的先后顺序将他们链接为一个包注释）
如果包注释很大，通常会放到一个独立的doc.go文件中。


2.6.1 导入包（p73）
47. 按照惯例，一个包的名字和包的导入路径的最后一个字段相同。
例如：GoNote\3GOshengjing\ch2\tempconv包的名字一般是tempconv。

2.6.2 包的初始化（p75）

48. 初始化函数 (p75)

对于在包级别声明的变量，如果有初始化表达式则用表达式初始化。
还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。
在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。

func init(){ /*...*/ }

init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。
在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
（有示例代码）
10.5 还有有关init函数的内容。


2.7 作用域（p78）

49. 各种情况的作用域
对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。

任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。

对于导入的包，如tempconv导入的fmt包，则是对应源文件的作用域，因此只能在当前的文件中访问导入的fmt包。
当前包的其他源文件无法访问在当前源文件导入的包。

还有许多声明语句，如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。


50. 控制流标号，就是break、continue、或goto语句后面跟着的哪种标号，则是函数级的作用域。


51. 如果一个名字在内部和外部的块分别声明过，则内部块的声明首先被找到。
在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问：

func f() {}

var g = "g"

func main(){
	f := "f"
	fmt.Println(f) // "f"; local var f shadows package-level func f  (本地的var f，覆盖了包级的f函数)
	fmt.Println(g) // "g"; package-level var
	fmt.Println(h) // compile error: undefined:h
} 

52. 注意短变量声明语句的作用域范围。
注意避免 := 出现的潜在的问题。(查看p81示例)

正确的方法：
var cwd string

func init(){
	var err error
	cwd, err = os.Getwd()//单独声明err变量，避免了使用：=
	if err != nil{
		log.Fatalf("os.Getwd faile: %v", error)
	}
}

第二章讲了包、文件、声明和语句如何表达一个程序结构。
